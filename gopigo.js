// Generated by CoffeeScript 1.8.0
(function() {
  var LED_L, LED_R, address, bus, bwd, bwd_cmd, decrease_speed, device, dis_com_timeout_cmd, dis_enc_cmd, dis_servo_cmd, disable_com_timeout, disable_encoders, disable_servo, dspd_cmd, en_com_timeout_cmd, en_enc_cmd, en_servo_cmd, enable_com_timeout, enable_encoders, enable_servo, enc_tgt, enc_tgt_cmd, fs, fw_ver, fw_ver_cmd, fwd, fwd_cmd, i2c, increase_speed, ispd_cmd, led, led_cmd, led_off, led_on, left, left_cmd, left_rot, left_rot_cmd, motor_bwd, motor_bwd_cmd, motor_fwd, motor_fwd_cmd, msleep, readByte, read_enc_status, read_enc_status_cmd, read_status, read_timeout_status, right, right_cmd, right_rot, right_rot_cmd, servo, servo_cmd, set_left_speed, set_left_speed_cmd, set_right_speed, set_right_speed_cmd, set_speed, sleep, stop, stop_cmd, timeout_status_cmd, us_cmd, us_dist, volt, volt_cmd, writeNumber, write_i2c_block;

  i2c = require('i2c');

  address = 0x08;

  fs = require("fs");

  if (fs.existsSync("/dev/i2c-0")) {
    device = "/dev/i2c-0";
  } else if (fs.existsSync("/dev/i2c-1")) {
    device = "/dev/i2c-1";
  } else {
    console.log("ERROR: GoPiGo could not determine your i2c device!");
    exit(1);
  }

  bus = new i2c(address, {
    device: device
  });

  fwd_cmd = [119];

  motor_fwd_cmd = [105];

  bwd_cmd = [115];

  motor_bwd_cmd = [107];

  left_cmd = [97];

  left_rot_cmd = [98];

  right_cmd = [100];

  right_rot_cmd = [110];

  stop_cmd = [120];

  ispd_cmd = [116];

  dspd_cmd = [103];

  volt_cmd = [118];

  us_cmd = [117];

  led_cmd = [108];

  servo_cmd = [101];

  enc_tgt_cmd = [50];

  fw_ver_cmd = [20];

  en_enc_cmd = [51];

  dis_enc_cmd = [52];

  read_enc_status_cmd = [53];

  en_servo_cmd = [61];

  dis_servo_cmd = [60];

  set_left_speed_cmd = [70];

  set_right_speed_cmd = [71];

  en_com_timeout_cmd = [80];

  dis_com_timeout_cmd = [81];

  timeout_status_cmd = [82];

  LED_L = 1;

  LED_R = 0;

  sleep = require('sleep');

  msleep = function(ms) {
    return sleep.usleep(1000 * ms);
  };

  write_i2c_block = function(block) {
    var ret;
    ret = 1;
    bus.writeBytes(1, block, function(err) {
      if (err != null) {
        return ret = -1;
      }
    });
    return ret;
  };

  writeNumber = function(value) {
    var ret;
    ret = 1;
    bus.writeByte(value, function(err) {
      if (err != null) {
        return ret = -1;
      }
    });
    return ret;
  };

  readByte = function() {
    return bus.readByte(function(err, res) {
      if (err) {
        return -1;
      } else {
        return res;
      }
    });
  };

  fwd = function() {
    return write_i2c_block(fwd_cmd.concat([0, 0, 0]));
  };

  motor_fwd = function() {
    return write_i2c_block(motor_fwd_cmd.concat([0, 0, 0]));
  };

  bwd = function() {
    return write_i2c_block(bwd_cmd.concat([0, 0, 0]));
  };

  motor_bwd = function() {
    return write_i2c_block(motor_bwd_cmd.concat([0, 0, 0]));
  };

  left = function() {
    return write_i2c_block(left_cmd.concat([0, 0, 0]));
  };

  left_rot = function() {
    return write_i2c_block(left_rot_cmd.concat([0, 0, 0]));
  };

  right = function() {
    return write_i2c_block(right_cmd.concat([0, 0, 0]));
  };

  right_rot = function() {
    return write_i2c_block(right_rot_cmd.concat([0, 0, 0]));
  };

  stop = function() {
    return write_i2c_block(stop_cmd.concat([0, 0, 0]));
  };

  increase_speed = function() {
    return write_i2c_block(ispd_cmd.concat([0, 0, 0]));
  };

  decrease_speed = function() {
    return write_i2c_block(dspd_cmd.concat([0, 0, 0]));
  };

  volt = function() {
    var b1, b2, v;
    write_i2c_block(volt_cmd.concat([0, 0, 0]));
    msleep(100);
    b1 = readByte();
    b2 = readByte();
    if (b1 !== -1 && b2 !== -1) {
      v = b1 * 256 + b2;
      v = (5 * v / 1024) / .4;
      v = v * 100;
      v = Math.round(v);
      return v / 100;
    } else {
      return -1;
    }
  };

  us_dist = function(pin) {
    var b1, b2;
    write_i2c_block(us_cmd.concat([pin, 0, 0]));
    msleep(80);
    b1 = readByte();
    b2 = readByte();
    if (b1 !== -1 && b2 !== -1) {
      return b1 * 256 + b2;
    } else {
      return -1;
    }
  };

  led = function(l_id, power) {
    power = Math.min(255, Math.max(0, power));
    if (l_id === LED_L || l_id === LED_R) {
      return write_i2c_block(led_cmd.concat([l_id, power, 0]));
    }
  };

  led_on = function(l_id) {
    if (l_id === LED_L || l_id === LED_R) {
      return write_i2c_block(led_cmd.concat([l_id, 255, 0]));
    }
  };

  led_off = function(l_id) {
    if (l_id === LED_L || l_id === LED_R) {
      return write_i2c_block(led_cmd.concat([l_id, 0, 0]));
    }
  };

  servo = function(position) {
    return write_i2c_block(servo_cmd.concat([position, 0, 0]));
  };

  enc_tgt = function(m1, m2, target) {
    var m_sel;
    if (m1 > 1 || m1 < 0 || m2 > 1 || m2 < 0) {

    } else {
      m_sel = m1 * 2 + m2;
      return write_i2c_block(enc_tgt_cmd.concat([m_sel, target / 256, target % 256]));
    }
  };

  fw_ver = function() {
    var ver;
    write_i2c_block(fw_ver_cmd.concat([0, 0, 0]));
    msleep(100);
    ver = readByte;
    readByte(address);
    if (ver !== -1) {
      return ver / 10;
    } else {
      return -1;
    }
  };

  enable_encoders = function() {
    return write_i2c_block(en_enc_cmd.concat([0, 0, 0]));
  };

  disable_encoders = function() {
    return write_i2c_block(dis_enc_cmd.concat([0, 0, 0]));
  };

  enable_servo = function() {
    return write_i2c_block(en_servo_cmd.concat([0, 0, 0]));
  };

  disable_servo = function() {
    return write_i2c_block(dis_servo_cmd.concat([0, 0, 0]));
  };

  set_left_speed = function(speed) {
    if (speed > 255) {
      speed = 255;
    } else if (speed < 0) {
      speed = 0;
    }
    return write_i2c_block(set_left_speed_cmd.concat([speed, 0, 0]));
  };

  set_right_speed = function(speed) {
    if (speed > 255) {
      speed = 255;
    } else if (speed < 0) {
      speed = 0;
    }
    return write_i2c_block(set_right_speed_cmd.concat([speed, 0, 0]));
  };

  set_speed = function(speed) {
    if (speed > 255) {
      speed = 255;
    } else if (speed < 0) {
      speed = 0;
    }
    setTimeout(set_left_speed, 0, speed);
    return set_right_speed(speed);
  };

  enable_com_timeout = function(timeout) {
    return write_i2c_block(en_com_timeout_cmd.concat([timeout / 256, timeout % 256, 0]));
  };

  disable_com_timeout = function() {
    return write_i2c_block(dis_com_timeout_cmd.concat([0, 0, 0]));
  };

  read_status = function() {
    var st, st_reg;
    st = readByte;
    st_reg = [st & (1 << 0), (st & (1 << 1)) / 2];
    return st_reg;
  };

  read_enc_status = function() {
    var st;
    st = read_status();
    return st[0];
  };

  read_timeout_status = function() {
    var st;
    st = read_status();
    return st[1];
  };

  module.exports = {
    LED_L: 1,
    LED_R: 0,
    fwd: fwd,
    motor_fwd: motor_fwd,
    bwd: bwd,
    motor_bwd: motor_bwd,
    left: left,
    left_rot: left_rot,
    right: right,
    right_rot: right_rot,
    stop: stop,
    increase_speed: increase_speed,
    decrease_speed: decrease_speed,
    volt: volt,
    us_dist: us_dist,
    led: led,
    led_on: led_on,
    led_off: led_off,
    servo: servo,
    enc_tgt: enc_tgt,
    fw_ver: fw_ver,
    enable_encoders: enable_encoders,
    disable_encoders: disable_encoders,
    enable_servo: enable_servo,
    disable_servo: disable_servo,
    set_left_speed: set_left_speed,
    set_right_speed: set_right_speed,
    set_speed: set_speed,
    enable_com_timeout: enable_com_timeout,
    disable_com_timeout: disable_com_timeout,
    read_status: read_status,
    read_enc_status: read_enc_status,
    read_timeout_status: read_timeout_status
  };

}).call(this);
